"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTheme = exports.useTheme = exports.PreventFlashOnWrongTheme = exports.ThemeProvider = exports.mediaQuery = exports.themes = exports.Theme = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const useBroadcastChannel_1 = require("./useBroadcastChannel");
const useCorrectCssTransition_1 = require("./useCorrectCssTransition");
var Theme;
(function (Theme) {
    Theme["DARK"] = "dark";
    Theme["LIGHT"] = "light";
})(Theme = exports.Theme || (exports.Theme = {}));
exports.themes = Object.values(Theme);
const ThemeContext = (0, react_1.createContext)(undefined);
ThemeContext.displayName = 'ThemeContext';
const prefersLightMQ = '(prefers-color-scheme: light)';
const getPreferredTheme = () => window.matchMedia(prefersLightMQ).matches ? Theme.LIGHT : Theme.DARK;
exports.mediaQuery = typeof window !== 'undefined' ? window.matchMedia(prefersLightMQ) : null;
function ThemeProvider({ children, specifiedTheme, themeAction, disableTransitionOnThemeChange = false, }) {
    const ensureCorrectTransition = (0, useCorrectCssTransition_1.useCorrectCssTransition)({
        disableTransitions: disableTransitionOnThemeChange,
    });
    const [theme, setTheme] = (0, react_1.useState)(() => {
        // On the server, if we don't have a specified theme then we should
        // return null and the clientThemeCode will set the theme for us
        // before hydration. Then (during hydration), this code will get the same
        // value that clientThemeCode got so hydration is happy.
        if (specifiedTheme) {
            return exports.themes.includes(specifiedTheme) ? specifiedTheme : null;
        }
        // there's no way for us to know what the theme should be in this context
        // the client will have to figure it out before hydration.
        if (typeof window !== 'object')
            return null;
        return getPreferredTheme();
    });
    const [themeDefinedBy, setThemeDefinedBy] = (0, react_1.useState)(specifiedTheme ? 'USER' : 'SYSTEM');
    const broadcastThemeChange = (0, useBroadcastChannel_1.useBroadcastChannel)('remix-themes', e => {
        ensureCorrectTransition(() => {
            setTheme(e.data.theme);
            setThemeDefinedBy(e.data.definedBy);
        });
    });
    (0, react_1.useEffect)(() => {
        if (themeDefinedBy === 'USER') {
            return () => { };
        }
        const handleChange = (ev) => {
            ensureCorrectTransition(() => {
                setTheme(ev.matches ? Theme.LIGHT : Theme.DARK);
            });
        };
        exports.mediaQuery === null || exports.mediaQuery === void 0 ? void 0 : exports.mediaQuery.addEventListener('change', handleChange);
        return () => exports.mediaQuery === null || exports.mediaQuery === void 0 ? void 0 : exports.mediaQuery.removeEventListener('change', handleChange);
    }, [ensureCorrectTransition, themeDefinedBy]);
    const handleThemeChange = (0, react_1.useCallback)(value => {
        const nextTheme = typeof value === 'function' ? value(theme) : value;
        if (nextTheme === null) {
            const preferredTheme = getPreferredTheme();
            ensureCorrectTransition(() => {
                setTheme(preferredTheme);
                setThemeDefinedBy('SYSTEM');
                broadcastThemeChange({ theme: preferredTheme, definedBy: 'SYSTEM' });
            });
            fetch(`${themeAction}`, {
                method: 'POST',
                body: JSON.stringify({ theme: null }),
            });
        }
        else {
            ensureCorrectTransition(() => {
                setTheme(nextTheme);
                setThemeDefinedBy('USER');
                broadcastThemeChange({ theme: nextTheme, definedBy: 'USER' });
            });
            fetch(`${themeAction}`, {
                method: 'POST',
                body: JSON.stringify({ theme: nextTheme }),
            });
        }
    }, [broadcastThemeChange, ensureCorrectTransition, theme, themeAction]);
    const value = (0, react_1.useMemo)(() => [theme, handleThemeChange, { definedBy: themeDefinedBy }], [theme, handleThemeChange, themeDefinedBy]);
    return (0, jsx_runtime_1.jsx)(ThemeContext.Provider, { value: value, children: children });
}
exports.ThemeProvider = ThemeProvider;
const clientThemeCode = String.raw `
(() => {
  const theme = window.matchMedia(${JSON.stringify(prefersLightMQ)}).matches
    ? 'light'
    : 'dark';
  
  const cl = document.documentElement.classList;
  const dataAttr = document.documentElement.dataset.theme;

  if (dataAttr != null) {
    const themeAlreadyApplied = dataAttr === 'light' || dataAttr === 'dark';
    if (!themeAlreadyApplied) {
      document.documentElement.dataset.theme = theme;
    }
  } else {
    const themeAlreadyApplied = cl.contains('light') || cl.contains('dark');
    if (!themeAlreadyApplied) {
      cl.add(theme);
    }
  }
  
  const meta = document.querySelector('meta[name=color-scheme]');
  if (meta) {
    if (theme === 'dark') {
      meta.content = 'dark light';
    } else if (theme === 'light') {
      meta.content = 'light dark';
    }
  }
})();
`;
function PreventFlashOnWrongTheme({ ssrTheme, nonce, }) {
    const [theme] = useTheme();
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("meta", { name: "color-scheme", content: theme === 'light' ? 'light dark' : 'dark light' }), ssrTheme ? null : ((0, jsx_runtime_1.jsx)("script", { 
                // NOTE: we cannot use type="module" because that automatically makes
                // the script "defer". That doesn't work for us because we need
                // this script to run synchronously before the rest of the document
                // is finished loading.
                dangerouslySetInnerHTML: { __html: clientThemeCode }, nonce: nonce, suppressHydrationWarning: true }))] }));
}
exports.PreventFlashOnWrongTheme = PreventFlashOnWrongTheme;
function useTheme() {
    const context = (0, react_1.useContext)(ThemeContext);
    if (context === undefined) {
        throw new Error('useTheme must be used within a ThemeProvider');
    }
    return context;
}
exports.useTheme = useTheme;
function isTheme(value) {
    return typeof value === 'string' && exports.themes.includes(value);
}
exports.isTheme = isTheme;
